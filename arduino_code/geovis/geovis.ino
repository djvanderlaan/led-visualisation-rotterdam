#include "flashled.h"
// flashled needs data on pin 11 and clock on 13.
// There are 25 LEDS for the neighbourhoods


// When LOGGING is set to 1 logging info is written to Serial
#define LOGGING 1

// =================================================================
// PALETTE
//
// 0 = Viridis
// 1 = Plasma
// 2 = Sunset
// 3 = SunsetDark
// 4 = ag_GrnYl
// 5 = Zissou 1
const int palette_num = 1;
const int palette_size = 8*2*4;

const uint8_t palette[] PROGMEM = { 
//Viridis,
0xFF, 0x4C, 0x00, 0x3C,
0xFF, 0x70, 0x38, 0x2A,
0xFF, 0x85, 0x65, 0x00,
0xFF, 0x86, 0x8C, 0x00,
0xFF, 0x70, 0xAB, 0x00,
0xFF, 0x44, 0xC2, 0x78,
0xFF, 0x2E, 0xCC, 0xCA,
0xFF, 0x0E, 0x0E, 0x0D,
0xFF, 0x1F, 0x00, 0x18,
0xFF, 0x2D, 0x16, 0x11,
0xFF, 0x35, 0x28, 0x00,
0xFF, 0x36, 0x38, 0x00,
0xFF, 0x2D, 0x44, 0x00,
0xFF, 0x1B, 0x4E, 0x30,
0xFF, 0x12, 0x52, 0x51,
0xFF, 0x06, 0x06, 0x05,
//Plasma,
0xFF, 0x7B, 0x16, 0x00,
0xFF, 0x7F, 0x00, 0x5B,
0xFF, 0x7A, 0x12, 0x89,
0xFF, 0x66, 0x46, 0xA8,
0xFF, 0x34, 0x78, 0xBA,
0xFF, 0x00, 0xAD, 0xBD,
0xFF, 0x40, 0xE6, 0xAE,
0xFF, 0x0E, 0x0E, 0x0D,
0xFF, 0x31, 0x09, 0x00,
0xFF, 0x33, 0x00, 0x24,
0xFF, 0x31, 0x07, 0x37,
0xFF, 0x29, 0x1C, 0x43,
0xFF, 0x15, 0x30, 0x4A,
0xFF, 0x00, 0x45, 0x4C,
0xFF, 0x1A, 0x5C, 0x46,
0xFF, 0x06, 0x06, 0x05,
//Sunset,
0xFF, 0x8E, 0x45, 0x5A,
0xFF, 0x97, 0x4B, 0x85,
0xFF, 0x95, 0x59, 0xA6,
0xFF, 0x88, 0x70, 0xBE,
0xFF, 0x79, 0x90, 0xC6,
0xFF, 0x76, 0xB0, 0xC7,
0xFF, 0x8B, 0xD0, 0xC2,
0xFF, 0x0E, 0x0E, 0x0D,
0xFF, 0x39, 0x1C, 0x24,
0xFF, 0x3C, 0x1E, 0x35,
0xFF, 0x3C, 0x24, 0x42,
0xFF, 0x36, 0x2D, 0x4C,
0xFF, 0x30, 0x3A, 0x4F,
0xFF, 0x2F, 0x47, 0x50,
0xFF, 0x37, 0x53, 0x4E,
0xFF, 0x06, 0x06, 0x05,
//SunsetDark,
0xFF, 0x5D, 0x1A, 0x64,
0xFF, 0x6A, 0x20, 0x8A,
0xFF, 0x6D, 0x31, 0xAC,
0xFF, 0x62, 0x51, 0xC5,
0xFF, 0x64, 0x7D, 0xCB,
0xFF, 0x74, 0xA2, 0xCC,
0xFF, 0x8F, 0xC3, 0xCC,
0xFF, 0x0E, 0x0E, 0x0D,
0xFF, 0x25, 0x0A, 0x28,
0xFF, 0x2A, 0x0D, 0x37,
0xFF, 0x2C, 0x13, 0x45,
0xFF, 0x27, 0x20, 0x4F,
0xFF, 0x28, 0x32, 0x51,
0xFF, 0x2E, 0x41, 0x52,
0xFF, 0x39, 0x4E, 0x52,
0xFF, 0x06, 0x06, 0x05,
//ag_GrnYl,
0xFF, 0x5E, 0x4D, 0x1E,
0xFF, 0x6C, 0x66, 0x00,
0xFF, 0x73, 0x7E, 0x00,
0xFF, 0x71, 0x96, 0x12,
0xFF, 0x68, 0xAD, 0x4E,
0xFF, 0x5A, 0xC2, 0x83,
0xFF, 0x53, 0xD7, 0xBE,
0xFF, 0x0E, 0x0E, 0x0D,
0xFF, 0x25, 0x1F, 0x0C,
0xFF, 0x2B, 0x29, 0x00,
0xFF, 0x2E, 0x32, 0x00,
0xFF, 0x2D, 0x3C, 0x07,
0xFF, 0x2A, 0x45, 0x1F,
0xFF, 0x24, 0x4D, 0x34,
0xFF, 0x21, 0x56, 0x4C,
0xFF, 0x06, 0x06, 0x05,
//Zissou 1,
0xFF, 0x9F, 0x8A, 0x2F,
0xFF, 0x8E, 0xA0, 0x45,
0xFF, 0x86, 0xAD, 0x7F,
0xFF, 0x27, 0xB7, 0xBB,
0xFF, 0x16, 0x94, 0xBA,
0xFF, 0x00, 0x6B, 0xBA,
0xFF, 0x19, 0x16, 0xC4,
0xFF, 0x0E, 0x0E, 0x0D,
0xFF, 0x40, 0x37, 0x13,
0xFF, 0x39, 0x40, 0x1C,
0xFF, 0x36, 0x45, 0x33,
0xFF, 0x0F, 0x49, 0x4B,
0xFF, 0x09, 0x3B, 0x4A,
0xFF, 0x00, 0x2B, 0x4A,
0xFF, 0x0A, 0x09, 0x4E,
0xFF, 0x06, 0x06, 0x05
};

// =================================================================
// DATASETS
//
const int data_size = 30+7;
const int ndatasets = 6;
const uint8_t data[] PROGMEM = { 
  // dataset 0 = reference dataset with uniform colour and therefore 
  // not an actual dataset
  // 0, 1, 2, 3, 4, 5, 6, 7, 7, 7,
  // 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
  // 7, 7, 7, 7, 7,     1,1,1,1,1,1,1,1,1,1,1,1,
  // == dataset 0
  // var: HuishOnderOfRondSociaalMinimum_79
  // breaks: 1.5, 5, 7.5, 10, 12.5, 15, 17.5, 20
  5, 6, 3, 6, 15, 4, 3, 15, 15, 3, 2, 3, 4, 4, 7, 8, 8, 7, 2, 7, 1, 7, 1, 7, 7, 7, 7, 7, 7, 7, 6, 5, 4, 3, 2, 1, 0,
  // == dataset 1: bedrijven per km2 2020
  // var: BedrijfsvestigingenTotaal_91
  // breaks: 0, 1, 2, 4, 6, 10, 20, 25
  4, 5, 6, 5, 11, 5, 1, 15, 12, 1, 3, 3, 4, 3, 1, 10, 10, 0, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 5, 4, 3, 2, 1, 0,
  // == dataset 2
  // var: Omgevingsadressendichtheid_117
  // breaks: 0, 1000, 2000, 3000, 4000, 5000, 6000, 7000
  3, 4, 6, 5, 9, 6, 1, 8, 8, 1, 2, 2, 5, 2, 0, 11, 8, 0, 2, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 6, 5, 4, 3, 2, 1, 0,
  // == dataset 3
  // var: SES
  // breaks: -0.55, -0.45, -0.35, -0.25, -0.15, -0.1, 0, 0.1
  0, 0, 4, 1, 15, 3, 4, 15, 15, 4, 6, 4, 2, 2, 7, 15, 14, 7, 3, 7, 5, 7, 6, 7, 7, 7, 7, 7, 7, 7, 6, 5, 4, 3, 2, 1, 0,
  // == dataset 4
  // var: SES_MAD
  // breaks: 0.7, 0.8, 0.95, 0.98, 1, 1.05, 1.1, 1.15
  3, 5, 4, 5, 15, 4, 4, 15, 15, 4, 2, 2, 5, 3, 7, 15, 8, 7, 1, 7, 0, 7, 1, 7, 7, 7, 7, 7, 7, 7, 6, 5, 4, 3, 2, 1, 0,
  // == dataset 5
  // var: SES_change
  // breaks: -0.09, -0.065, -0.04, -0.015, 0.015, 0.04, 0.065, 0.09
  3, 1, 1, 0, 15, 1, 0, 15, 15, 0, 3, 4, 2, 4, 7, 15, 11, 7, 4, 7, 5, 7, 3, 7, 7, 7, 7, 7, 7, 7, 6, 5, 4, 3, 2, 1, 0,
  // == dataset 6
  // var: jongeren
  // breaks: 0, 22, 24, 26, 28, 30, 32, 34
  5, 5, 2, 5, 10, 3, 4, 15, 15, 4, 4, 3, 6, 4, 0, 12, 10, 7, 3, 7, 3, 7, 2, 7, 7, 7, 7, 7, 7, 7, 6, 5, 4, 3, 2, 1, 0,
  // == dataset 7
  // This is all lights active -> the same as no card; we will use
  // this to switch off the lights
};

// =================================================================
// READING THE PUNCHCARD VALUES
// 
const int punchcard1 = A0;
const int punchcard2 = A1;
const int punchcard4 = A2;
const int punchcard_threshold = 300;

int read_punchcard() {
  const int punchcard1_value = analogRead(punchcard1);
  const int punchcard2_value = analogRead(punchcard2);
  const int punchcard4_value = analogRead(punchcard4);
  const int value = (punchcard1_value > punchcard_threshold)*1 +
    (punchcard2_value > punchcard_threshold)*2 +
    (punchcard4_value > punchcard_threshold)*4;
#if LOGGING
  Serial.print("read_punchcard(): Punchcard values: ");
  Serial.print(punchcard1_value);
  Serial.print(",");
  Serial.print(punchcard2_value);
  Serial.print(",");
  Serial.print(punchcard4_value);
  Serial.print("-> value = ");
  Serial.println(value);
#endif
  return value;
}


// =================================================================
// DISPLAYING DATA
// 
void display_data(int dataset) { 
  if (dataset < 0 || dataset > ndatasets) {
#if LOGGING
    Serial.print("display_data(): dataset = ");
    Serial.print(dataset);
    Serial.print(" this is lower than 0 or higher than ndatasets = ");
    Serial.print(ndatasets);
    Serial.println("; turning off LED's");
#endif 
    flashled::turn_off_leds(data_size);
  } else {
#if LOGGING
    Serial.print("display_data(): showing dataset ");
    Serial.println(dataset);
#endif
    flashled::show_data(data+(dataset)*data_size, palette + palette_num*palette_size, data_size);
  }
}


// =================================================================
// SETUP
//
void setup() {
  flashled::begin();
#if LOGGING
  Serial.begin(9600);
#endif
}


// =================================================================
// LOOP
//
void loop() {
  const int punchcard_value = read_punchcard();
  display_data(punchcard_value);
  delay(500);
}
